---
title: "CS349 - User Interfaces"
url: "courses/CS349/"
summary: An introduction to contemporary user interfaces and its components, specifications, and architectures
ShowToc: true
math: true
---

> **Instructor:** Adrian Reetz \
> **Lectures:** M/W at 2:30pm \
> **Section:** 003 \
> \
> **Course Breakdown:** \
> Assignments: 4 $\times$ 15% \
> Quizzes: 5 $\times$ 4% \
> Final Exam: 1 $\times$ 20% \
> \
> **Course Description:** \
> An introduction to contemporary user interfaces, including the basics of human-computer interaction, the user interface design/evaluation process, the event abstraction, user interface components, specification of user interfaces, and the architectures within which user interfaces are developed. Implementation and evaluation of a typical user interface is considered.

## Introduction

### Motivation

 How does an average person describe a computer? A tool that can perform different tasks. They do so using an user interface, and we wish to design effective user interfaces (UIs). Good UIs empower people to do things they could not otherwise do and create digital tools that can change the world.

Interaction is a continuous process where a user expresses their intention to a system and the system presents feedback to this user. This dynamic between the human and the computer is called Human-Computer Interaction.

In this course, we primarily focus on creating graphical user interfaces and analyzing theories and methods relevant to interface design.

### CLIs vs GUIs

#### Command Line Interfaces (CLIs)

CLIs are very flexible, efficient, and can be easily automated. However, they require a lot of memorization and as such, their usage are limited to experts. Furthermore, they are not explorable (freely navigatable).

#### Graphical User Interfaces (GUIs)

GUIs are explorable, easy to use, and visually impactful to users. However, they do lack the flexibility, efficiency (they take up much more computer resources than CLIs), and automation capabilities that CLIs offer.

Almost all GUIs follow the WIMP Paradigm: (W)indows, (I)cons, (M)enus, (P)ointers. Every application is isolated within its own windows that can be moved, resized, and overlapped.


### Software Stack

1. Git(Lab) - Versioning Control
2. Gradle (7.4.2+) - Build Automation Tool
3. Kotlin (1.7.21) - Our programming language of choice
4. JavaFX - A software platform for creating and delivering desktop applications
5. Java SDK (17.0.5) - Required Dependency
6. IntelliJ IDEA - our IDE of choice for developing our software

First download IntelliJ then retreive the necessary dependencies by creating a project for the first time. Ensure that your version matches the versions specified here. Note:
* We will only be concerned with modifying content within the `src` folder
* The only thing we will really use from Gradle is the `application->run` task accessible at the right tool bar in the IntelliJ IDE. You can also run these programs from the command line if you wish.


### Kotlin

#### Characteristics of Kotlin
1. Supports imperative, object-oriented, and functional programming - Kotlin is best suitable (and recommended) for functional programming
2. Automatic memory management and garbage collection
3. Named arguments, default arguments, type inference, NULL handling
4. Fully interoperable with Java source and libraries
5. Multi-platform: Windows, Linux, Mac, Android, iOS
6. Kotlin's primary design objective is to shorten code

#### Kotlin Usage
* Structure your code for maintenance and extendability (aka. please don't do everything in main and actually use functions and classes when appropriate)
* Although I will not show code examples, you can learn a lot more about Kotlin's features on the [course website](https://student.cs.uwaterloo.ca/~cs349/) as well as online documentation