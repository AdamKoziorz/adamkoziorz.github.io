---
title: "CS349 - User Interfaces"
url: "courses/CS349/"
summary: An introduction to contemporary user interfaces and its components, specifications, and architectures
ShowToc: true
math: true
comments: true
---

> **Instructor:** Adrian Reetz \
> **Lectures:** M/W at 2:30pm \
> **Section:** 003 \
> \
> **Course Breakdown:** \
> Assignments: 4 $\times$ 15% \
> Quizzes: 5 $\times$ 4% \
> Final Exam: 1 $\times$ 20% \
> \
> **Course Description:** \
> An introduction to contemporary user interfaces, including the basics of human-computer interaction, the user interface design/evaluation process, the event abstraction, user interface components, specification of user interfaces, and the architectures within which user interfaces are developed. Implementation and evaluation of a typical user interface is considered.

 

# Introduction

## Motivation

 How does an average person describe a computer? A tool that can perform different tasks. They do so using an user interface, and we wish to design effective user interfaces (UIs). Good UIs empower people to do things they could not otherwise do and create digital tools that can change the world.

Interaction is a continuous process where a user expresses their intention to a system and the system presents feedback to this user. This dynamic between the human and the computer is called Human-Computer Interaction.

In this course, we primarily focus on creating graphical user interfaces and analyzing theories and methods relevant to interface design.

## CLIs vs GUIs

### Command Line Interfaces (CLIs)

CLIs are very flexible, efficient, and can be easily automated. However, they require a lot of memorization and as such, their usage are limited to experts. Furthermore, they are not explorable (freely navigatable).

<center>
<img src="/cs349-cli-example.jpg" width="450" height="300" alt="CLI Example">
</center>

### Graphical User Interfaces (GUIs)

GUIs are explorable, easy to use, and visually impactful to users. However, they do lack the flexibility, efficiency (they take up much more computer resources than CLIs), and automation capabilities that CLIs offer.

Almost all GUIs follow the **WIMP** Paradigm: **W**indows, **I**cons, **M**enus, **P**ointers. Every application is isolated within its own windows that can be moved, resized, and overlapped.

<center>
<img src="/cs349-gui-example.png" width="450" height="300" alt="GUI Example">
</center>


## Software Stack

1. Git(Lab) - Versioning Control
2. Gradle (7.4.2+) - Build Automation Tool
3. Kotlin (1.7.21) - Our programming language of choice
4. JavaFX - A software platform for creating and delivering desktop applications
5. Java SDK (17.0.5) - Required Dependency
6. IntelliJ IDEA - our IDE of choice for developing our software

First, you should download IntelliJ then retreive the necessary dependencies by creating a project for the first time. Ensure that your version matches the versions specified here.
* We will only be concerned with modifying content within the `src` folder
* The only thing we will really use from Gradle is the `application->run` task accessible at the right tool bar in the IntelliJ IDE. You can also run these programs from the command line if you wish


## Kotlin

### Characteristics of Kotlin
1. Supports imperative, object-oriented, and functional programming
2. Fully interoperable with Java source and libraries
3. Multi-platform: Windows, Linux, Mac, Android, iOS
4. Kotlin's primary design objective is to shorten code
5. Automatic memory management and garbage collection

### Kotlin Usage
* Structure your code for maintenance and extendability (aka. please don't do everything in main and actually use functions and classes when appropriate)
* Opt for a functional programming paradigm whenever possible
* Emphasize short, clean code that utilizes Kotlin's offerings
* Although I will not describe Kotlin's syntax and features here, you can learn a lot more about Kotlin's features on the [course website](https://student.cs.uwaterloo.ca/~cs349/) as well as online documentation



##  GUI Stack Components

GUI applications are ultimately programs, and they may require hardware access and specific libaries. Below showcases a hierarchy of stack components required to bring a GUI application to life:

**OS Kernel** $\rightarrow$ **Window Manager** $\rightarrow$ **UI Toolkit** $\rightarrow$ **Application**

At the core is the **OS kernel**, which allows the application to interact with hardware. On top of this OS kernel is a **Window Manager** that allows the application to communicate with the OS for creating, destroying, and managing application windows (including scaling, moving, minimizing, tiling, overlapping, etc.), and routing input to the correct window. Note that each window is independent, has no knowledge of other windows, and has its own coordinate system. In short, the Windows Manager "owns" the application window while the application "owns" the content.

Lastly, a **UI Toolkit** allows us to create the content for these windows, which in turn will create our **application**. These toolkits are a set of classes for building user interfaces. They come in low-level (OS specific) and high-level (general). Some things usually offered are:

* User Interface widgets (check boxes, buttons, labels, dropdowns, etc.)
* Graphics (shapes, images, animation)
* Media playback (sound and video)
* Input handling from the mouse and keyboard
* Access to cameras, sensors, etc.

Our UI ToolKit of choice will be JavaFX. We will now learn how to utilize JavaFX through Kotlin to create effective GUIs.

 

# Widgets and Layout

## Scene Trees

We can break down the visual components of a GUI into scenes. A scene graph is a tree structure that arranges all the elements of a screen into a hierarchy. With such a hierarchy, we can manage dependencies and increase efficiency of our operations. Here are some important terminology:

1. The **stage** is the top-level container (`javafx.scene.Stage`) representing the entire application window
2. **Scenes** are containers that contain the content of the application (`javafx.scene.Scene`), including the scene-graph
3. **Nodes** are the displayable objects or layouts (`javafx.scene.Node`)

Sometimes, we could have changes to one node that must propagate to its children. An analogy to this is moving your elbows also moves your arms. This is why a scene tree is much more ideal over something like an array.

### Example of a Scene Tree

Consider the example code below:

```kotlin
 1.  override fun start(stage: Stage) {
 2.      val greeting = Label("Hello CS349 :-)")
 3.      val vendor   = Label(System.getProperty("java.vendor"))
 4.      val version  = Label(System.getProperty("java.version"))
 5.
 6.      val javaInfo = HBox(vendor, version).apply {
 7.            alignment = Pos.CENTER
 8.      }
 9.      val root = VBox(greeting, javaInfo).apply { 
10.            alignment = Pos.CENTER 
11.      }
12. 
13.      stage.apply {
14.          scene = Scene(root, 300.0, 200.0)
15.          title = "Hello CS349!"
16.      }.show()
17.  }
```

1. At lines `1, 13-17`, we set up the stage of the application, which includes the scenes to present and the window's title
2. At line `14`, we create a scene using a root node, which we decide will be the node created at lines `9-11` labelled `root`
3. At lines `2-11`, we create the nodes, which will be the displayed objects

The application then looks like below (excluding the red border). Here, the stage is the application window, the scene is the window content, and the nodes are the labels and their alignments. The scene tree consisting of these nodes is presented.

<center>
<img src="/cs349-javafx-example.png" width="350" height="270" alt="Scene Tree Example">
</center>

<center>
<img src="/cs349-javafx-example-2.png" width="350" height="270" alt="Scene Tree Example">
</center>


## Widgets

Widgets correspond to the leaves of the scene tree and are one of three key parts of an interface. Each widget has their own distinct behaviour. Examples of widgets include buttons, menus, radio buttons, checkboxes, sliders, textboxs, scrollbars, and spinners. Some primary functions of widgets are to:

1. Capture user input 
2. Generate events (send data to other parts of the program)
3. Provide user feedback (show that it's being used)
4. Maintain state (contains their own data)

When creating widgets, we should take into account consistency across other programs, workflow speed, and visual representation. Additionally, despite user interfaces being very important for interacting with problems, most users do not want to see an interface. We then need to take into account the real estate of the display.

Lastly, we could have multiple widgets for executing the same functionality (some programs have a "copy" menu option, "copy" button, and "copy" keyboard shortcut).

### Logical Inputs

There is a key subtle differences between logical inputs and widgets. Logical inputs describe underlying functionality (state and events) while widgets are visual implementations of logical inputs that could have further properties like position and size. What we think as a "button", for example, is a logical button with visual properties.

Here are examples of logical inputs:

1. **Logical Display**: Show data and provide feedback

    <blockquote style="border:none">
    Labels and images are key examples of this. They require a single text state. We could opt for low resolution (imprecise) or high resolution (precise) visualizations
    </blockquote>

2. **Logical Text Entry**: Allows users to enter text and see current state

    <blockquote style="border:none">
    Text fields and areas are key examples of this. They require a text and selection states, as well as events for text change, completed entries, and selection changes
    </blockquote>

3. **Logical Button**: Perform a single interaction with one fixed action

    <blockquote style="border:none">
    Buttons and menus are key examples of this. They require one event, the button activation/click
    </blockquote>

4. **Logical Selection**: Allows users to visually select between states

    <blockquote style="border:none">
    There are multiple kinds of selections:

    *  Boolean (only two states - checkboxes and toggles)
    *  Discrete (multiple discrete states - radio buttons and choice boxes)
    *  Continuous (continuous states - sliders and spinners)

    They require a state to store the value chosen (a boolean, index/element, and number respectively) and an event for when the selection is changed
    </blockquote>

