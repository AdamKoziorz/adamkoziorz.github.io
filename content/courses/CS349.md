---
title: "CS349 - User Interfaces"
url: "courses/CS349/"
summary: An introduction to contemporary user interfaces and its components, specifications, and architectures
ShowToc: true
math: true
comments: true
---

> **Instructor:** Adrian Reetz \
> **Lectures:** M/W at 2:30pm \
> **Section:** 003 \
> \
> **Course Breakdown:** \
> Assignments: 4 $\times$ 15% \
> Quizzes: 5 $\times$ 4% \
> Final Exam: 1 $\times$ 20% \
> \
> **Course Description:** \
> An introduction to contemporary user interfaces, including the basics of human-computer interaction, the user interface design/evaluation process, the event abstraction, user interface components, specification of user interfaces, and the architectures within which user interfaces are developed. Implementation and evaluation of a typical user interface is considered.

Â 

# Introduction

## Motivation

 How does an average person describe a computer? A tool that can perform different tasks. They do so using an user interface, and we wish to design effective user interfaces (UIs). Good UIs empower people to do things they could not otherwise do and create digital tools that can change the world.

Interaction is a continuous process where a user expresses their intention to a system and the system presents feedback to this user. This dynamic between the human and the computer is called Human-Computer Interaction.

In this course, we primarily focus on creating graphical user interfaces and analyzing theories and methods relevant to interface design.

## CLIs vs GUIs

### Command Line Interfaces (CLIs)

CLIs are very flexible, efficient, and can be easily automated. However, they require a lot of memorization and as such, their usage are limited to experts. Furthermore, they are not explorable (freely navigatable).

### Graphical User Interfaces (GUIs)

GUIs are explorable, easy to use, and visually impactful to users. However, they do lack the flexibility, efficiency (they take up much more computer resources than CLIs), and automation capabilities that CLIs offer.

Almost all GUIs follow the WIMP Paradigm: (W)indows, (I)cons, (M)enus, (P)ointers. Every application is isolated within its own windows that can be moved, resized, and overlapped.


## Software Stack

1. Git(Lab) - Versioning Control
2. Gradle (7.4.2+) - Build Automation Tool
3. Kotlin (1.7.21) - Our programming language of choice
4. JavaFX - A software platform for creating and delivering desktop applications
5. Java SDK (17.0.5) - Required Dependency
6. IntelliJ IDEA - our IDE of choice for developing our software

First, you should download IntelliJ then retreive the necessary dependencies by creating a project for the first time. Ensure that your version matches the versions specified here.
* We will only be concerned with modifying content within the `src` folder
* The only thing we will really use from Gradle is the `application->run` task accessible at the right tool bar in the IntelliJ IDE. You can also run these programs from the command line if you wish


## Kotlin

### Characteristics of Kotlin
1. Supports imperative, object-oriented, and functional programming - Kotlin is best suitable (and recommended) for functional programming
2. Fully interoperable with Java source and libraries
3. Multi-platform: Windows, Linux, Mac, Android, iOS
4. Kotlin's primary design objective is to shorten code
5. Automatic memory management and garbage collection

### Quick Notes about Kotlin

* Kotlin supports named arguments, default arguments, and type inference
* Data is either mutable/non-constant (`var`) or immutable/constant (`val`), and we should try to utilize `val` as much as possible
* Functions in Kotlin returns `Unit` (similar to `void`) unless otherwise specified using the `: Type` syntax
* Functions are first-class language elements and can be stored as data. This means you can pass functions as a parameter
* Anonymous functions, objects, and classes, as well as lambda functions, are supported
* If a class does not inherit from any class, it inherits from `Any`
* Inheritance, abstract classes, and interfaces in Kotlin are very similar to other languages
* Kotlin provides `data` classes as well as `enum` classes
* Kotlin offers `public` (default), `protected`, `private`, and `internal` scopes
* `If` and `When` conditionals can yield a value
* Avoid index-based `for` loops in Kotlin - there are alternatives available (`forEach` is preferable, but you can also use `for ((index, value) in collection))` if necessary)
* Kotlin provides list, set, and map collections, both immutable and mutable, and various higher order functions for them (`.filter`, `.map`, `.fold`, `.forEach`, `.groupBy`, etc.) that work with iterators
* Data that can be `null` must have their types ending with `?` like `var i: Int? = 3`. You can then use the Safe Call operator `?` and the Elvis operator (`?:`) to deal with `null` data. You can also use the `!!` operator to change from a nullable type to a non-nullable type, but only use this for when you know the data is not `null`

### Kotlin Usage
* Structure your code for maintenance and extendability (aka. please don't do everything in main and actually use functions and classes when appropriate)
* Although I will not show code examples, you can learn a lot more about Kotlin's features on the [course website](https://student.cs.uwaterloo.ca/~cs349/) as well as online documentation




## JavaFX

###  GUI Stack

**OS Kernel** $\rightarrow$ **Window Manager** $\rightarrow$ **UI Toolkit** $\rightarrow$ **Application**

GUIs uses many layers of different technologies. At the core is the **OS kernel**, which allows the application to interact with hardware.

On top of this OS kernel is a **Window Manager** that allows the application to communicate with the OS for creating, destroying, and managing application windows (including scaling, moving, minimizing, tiling, overlapping, etc.), and routing input to the correct window. Note that each window is independent, has no knowledge of other windows, and has its own coordinate system. In short, the Windows Manager "owns" the application window while the application "owns" the content.

Lastly, a **UI Toolkit** allows us to create the content for these windows, which in turn will create our **application**. These toolkits are a set of classes for building User Interfaces. They come in low-level (OS specific) and high-level (general). Some things offered:

* User Interface widgets (check boxes, buttons, labels, dropdowns, etc.)
* Graphics (shapes, images, animation)
* Media playback (sound and video)
* Input handling from the mouse and keyboard
* Access to cameras, sensors, etc.

Our UI ToolKit of choice will be JavaFX.


### JavaFX Basics

Let's look at a very basic program using JavaFX:
```kotlin
import ...

class HelloFXApplication : Application() {
    override fun start(stage: Stage) {
        val scene  = Scene(StackPane(Label("Hello CS349!")), 300.0, 200.0)
        stage.title = "Hello CS349!"
        stage.scene = scene
        stage.show()
    }
}
```

When the application is launched, JavaFX will create an instance of the specified `Application()` class and call its `init()` and `start()` methods. Then, the `stop()` method will be called when the application is finished either through `exit()` or when all windows have been closed.

This is the output of the above program:

<center>
<img src="/CS349-hello-world.png" width="300" height="240" alt="Hello World">
</center>

We can break down the visual components of a GUI into scenes. A scene graph is a tree structure that arranges all the elements of a screen into a hierarchy. With this, we can manage dependencies and increase efficiency of our operations. Here are some related terminology:

1. Stage is the top-level container (`javafx.scene.Stage`) representing the entire application window
2. Scenes are containers that contain the content of the application (`javafx.scene.Scene`), includes the scene-graph
3. The displayable objects or layouts for displaying them is a Node (`javafx.scene.Node`)

We use a scene tree because we could have changes to one node that must propagate to its children. 