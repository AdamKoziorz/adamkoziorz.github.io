---
title: "CS350 - Operating Systems"
url: "courses/CS350/"
summary: An introduction to the fundamentals of operating system function, design, and implementation
ShowToc: true
math: true
---

> **Instructor:** Rob Hackman \
> **Lectures:** T/Th at 10:00am \
> **Section:** 001 \
> \
> **Course Breakdown:** \
> Assignments: 2%, 12%, 11%, 15% \
> Reading Assignments: 2 $\times$ 5% \
> Midterm: 1 $\times$ 20% \
> Final Exam: 1 $\times$ 30% \
> \
> **Course Description:** \
> An introduction to the fundamentals of operating system function, design, and implementation. Topics include concurrency, synchronization, processes, threads, scheduling, memory management, file systems, device management, and security.

 

## Introduction

### Motivation
How do multiple programs run at the same time and utilize computer resources? The "middle man" responsible for this is the Operating System (OS). This is a maturing field and many different computer science topics are OS issues (high-performance servers, resource consumption, security, databases, game engines, etc.)

We will learn the basics of operating systems, what they do, what issues they can face, and how they affect software. Some key concepts include multi-programming, concurrency, memory management, device management, and file systems. We will focus on these concepts with an emphasis on security and protection.


### What is an Operating System?

The operating system (OS) is a layer between applications and hardware that provides an abstraction to the hardware details, allowing programmers to interact with hardware securely and effectively.

Originally, they were just a library of standard services that didn't really offer any security and the system could only run one program at a time.

 Multitasking capabilities were then realized to make it appear as though multiple programs are running at the same time to address this problem, which initially had problems with ill-behaved processes (especially infinite loops and overwriting - see cooperative multitasking). However, preemption (kicking threads out of cores) and memory protection schemes were introduced to resolve these problems.

More features were eventually added, leading to a prototype of a modern OS.

#### How does the OS protect us?

1. Preemption: Give applications a resource, take it away if needed elsewhere
2. Interposition: Place the OS between application and "stuff", track all pieces that application allowed to use, and on every access, look in table to check that access legal
3. (Un)privileged Modes: Applications are unprivileged and the OS is privileged - protection operations can only be done in privileged mode. The CPU actually switches between these modes.

#### System Calls

If we have to perform system calls (unprivileged to privileged), then special instructions will invoke a `syscall` handler which stores the state of the registers, loads into the program counter a predetermined address in the kernel memory (enabling privileged mode), then returns back to the original application (disabling privileged mode).

We want to perform system calls if our application needs to do things that it cannot do in unprivileged mode. Higher-level functions such as `printf`, `gets`, `scanf`, etc. are built upon the `syscall` interface.

 

## Multi-Programming

The OS provides processes, threads, locks, and file I/O to applications. Let's focus on the process abstraction first.

### Processes and Threads

**Process:** An instance of a program running and provides execution details to the OS, including threads. Each process has their own unique process ID (PID). A process will always have at least one thread (the program entry point).

**Thread:** A sequence of executions. Threads are either running, blocked, or ready.

The OS enables multiple processes to run, increasing CPU utilization and reducing latency. Whenever a thread stalls for input, another thread will execute on the CPU core until input has been received (moving the thread into a ready state) AND the other thread has been kicked off by the OS. A nice real-life analogy to this is sharing equipment with someone on an fixed ON/OFF cycle.

Each process has its own view of the machine, which includes:
1. Its own address space
2. Its own open files
3. Its own virtual CPU (later)

This simplifies the programming model - Most programs do not care which other programs are running, but not all.


### User View of Processes

#### `int fork (void)`:
This creates a new process that is an exact copy of the current one.
1. Returns process ID of new process in "parent"
2. Returns `0` in "child"

#### `int waitpid (int pid, int *stat, int opt)`:
This is a syscall that can only be called on child processes. It waits for the child to finish and gets the status code of that child.
1. `pid` - process to wait for, or -1 for any
2. `stat` - will contain exit value or signal
3. `opt` - usually 0 or `WNOHANG`
4. Returns process ID or `-1` on error

If a process exits but its parent is still alive, then we must store the exit code status somehow. The best way to approach this is to destroy its information but leave the data structures available and leave an exit code.

You can only free processes when waitpid is called on it or when its parent exits (you need to check all the children in this case).

If process A creates process B and process A exits, then process B should **not** be killed. However, when process B returns, then it needs to check if its parents is alive, and if not, then process B is responsible for cleaning itself up.





