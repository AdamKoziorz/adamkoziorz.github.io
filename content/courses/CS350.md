---
title: "CS350 - Operating Systems"
url: "courses/CS350/"
summary: An introduction to the fundamentals of operating system function, design, and implementation
ShowToc: true
math: true
---

> **Instructor:** Rob Hackman \
> **Lectures:** T/Th at 10:00am \
> **Section:** 001 \
> \
> **Course Breakdown:** \
> Assignments: 2%, 12%, 11%, 15% \
> Reading Assignments: 2 $\times$ 5% \
> Midterm: 1 $\times$ 20% \
> Final Exam: 1 $\times$ 30% \
> \
> **Course Description:** \
> An introduction to the fundamentals of operating system function, design, and implementation. Topics include concurrency, synchronization, processes, threads, scheduling, memory management, file systems, device management, and security.

 

# Introduction

## Motivation
How do multiple programs run at the same time and utilize computer resources? The "middle man" responsible for this is the Operating System (OS). This is a maturing field and many different computer science topics are OS issues (high-performance servers, resource consumption, security, databases, game engines, etc.)

We will learn the basics of operating systems, what they do, what issues they can face, and how they affect software. Some key concepts include multi-programming, concurrency, memory management, device management, and file systems. We will focus on these concepts with an emphasis on security and protection.


## What is an Operating System?

The operating system (OS) is a layer between applications and hardware that provides an abstraction to the hardware details, allowing programmers to interact with hardware securely and effectively.

Originally, they were just a library of standard services that didn't really offer any security and the system could only run one program at a time.

 Multitasking capabilities were then realized to make it appear as though multiple programs are running at the same time to address this problem, which initially had problems with ill-behaved processes (especially infinite loops and overwriting - see cooperative multitasking). However, preemption (kicking threads out of cores) and memory protection schemes were introduced to resolve these problems.

More features were eventually added, leading to a prototype of a modern OS.

### How does the OS protect us?

1. Preemption: Give applications a resource, take it away if needed elsewhere
2. Interposition: Place the OS between application and "stuff", track all pieces that application allowed to use, and on every access, look in table to check that access legal
3. (Un)privileged Modes: Applications are unprivileged and the OS is privileged - protection operations can only be done in privileged mode. The CPU actually switches between these modes.

### System Calls

If we have to perform system calls (unprivileged to privileged), then special instructions will invoke a `syscall` handler which stores the state of the registers, loads into the program counter a predetermined address in the kernel memory (enabling privileged mode), then returns back to the original application (disabling privileged mode).

We want to perform system calls if our application needs to do things that it cannot do in unprivileged mode. Higher-level functions such as `printf`, `gets`, `scanf`, etc. are built upon the `syscall` interface.

 

# Multi-Programming

The OS provides processes, threads, locks, and file I/O to applications. Let's focus on the process abstraction first.

## Processes and Threads

**Process:** An instance of a program running and provides execution details to the OS, including threads. Each process has their own unique process ID (PID). A process will always have at least one thread (the program entry point).

**Thread:** A sequence of executions. Threads are either running, blocked, or ready.

The OS enables multiple processes to run, increasing CPU utilization and reducing latency. Whenever a thread stalls for input, another thread will execute on the CPU core until input has been received (moving the thread into a ready state) AND the other thread has been kicked off by the OS. A nice real-life analogy to this is sharing equipment with someone on an fixed ON/OFF cycle.

As a general rule for thread states:

* Running $\rightarrow$ Blocked: Asks for a resource that is not available
* Blocked $\rightarrow$  Ready: Resource becomes available
* Ready $\rightarrow$  Running: When the OS schedules it (core is available)
* Running $\rightarrow$  Ready: Yielding or preemption

Each process has its own view of the machine, which includes:
1. Its own address space
2. Its own open files
3. Its own virtual CPU (later)

This simplifies the programming model - Most programs do not care which other programs are running, but not all.


## User View of Processes: Functions

### `int fork (void)`:
This creates a new process that is an exact copy of the current one.
1. Returns process ID of new process in "parent"
2. Returns `0` in "child"

Example of the `fork()` procedure:

```c
#include <unistd.h>
#include <stdio.h>

int x = 0;

int main() {
    int rc;
    x = 0;
    rc = fork();
    if (rc == 0) {
        x = 10;
        printf("Child: %d\n", x);
    } else {
        printf("Parent: %d\n", x);
        x = 100;
    }
    printf("C: %d\n", x);
}

```
The processes are independent, so they have their own memory. Therefore, the child process will always print `10`, while the parent process will first print `0` then `100`. However, these print statements may execute in a different order. This is because the threads of these processes can be preempted before each print statement.

We would like to use forks in cases where we might want to have parallelism (Nginx, PostgreSQL, etc.). It is very simple to deal with as there are no arguments, and we can use the child to perform any different tasks like manipulate file descriptors, environment, and set resource limits.


### `int waitpid (int pid, int *stat, int opt)`:
This is a syscall that can only be called on child processes. It waits for the child to finish and gets the status code of that child.
1. `pid` - process to wait for, or -1 for any
2. `stat` - will contain exit value or signal
3. `opt` - usually 0 or `WNOHANG`
4. Returns process ID or `-1` on error

If a process exits but its parent is still alive, then we must store the exit code status somehow. The best way to approach this is to destroy its information but leave the data structures available and leave an exit code.

You can only free processes when waitpid is called on it or when its parent exits (you need to check all the children in this case).

If process A creates process B and process A exits, then process B should **not** be killed. However, when process B returns, then it needs to check if its parents is alive, and if not, then process B is responsible for cleaning itself up.

Example of the `waitpid()` procedure with `fork()`:
```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

int main() {
    int rc1, rc2, rc3;
    rc1 = fork();
    rc2 = fork();
    rc3 = fork();
    int exit_status;
    printf("1");                      // This gets printed 8 times!
    waitpid(rc1, &exit_status, 0);
    waitpid(rc2, &exit_status, 0);
    waitpid(rc3, &exit_status, 0);
}
```
Here, we guarantee that the parent process will finish only after all its children finishes.


### `void exit (int status)`:
This is a syscall that makes the current process cease to exist. The status shows up in `waitpid`. By convention:
1. Status of 0 if successful
2. Status of non-zero if unsuccessful


### `int kill (int pid, int sig)`:
Sends a signal to process `pid`.

### `int execv(char *prog, char **argv, char **envp)`:
1. `prog`: Full pathname of program to run
2. `argv`: Argument vector that gets passed to main
3. `envp`: Environment variables (eg. `PATH`, `HOME`)

Note that this does not create a new process - it changes the identity of the program instead. Furthermore, `execv` should not return any values.

Here is an example of a program that executes the `grep` program:
```c
#include <sys/wait.h>
#include <errno>

int main(int argc, char **argv) {
    int rc = fork();
    if (rc == 0) {
        char *args[] = {"grep", argv[1], "alice.txt", NULL};
        execvp("grep", args);
        printf("Execv error code: %d\n", x);
        printf("Execv errno: %d\n", errno);
    }
    int status;
    waitpid(rc, &status, 0);
    if (WEXITSTATUS(status) == 0) {
        printf("Word %s was found \n", argv[1]);
    } else {
        printf("Word %s was not found \n", argv[1]);
    }
}
```

### `int dup2 (int oldfd, int newfd)`

The following functions in this subsection concerns file descriptors which can be thought of as an open cursor to a file - part of the data of the file is stored. Opening a file is also an OS task.

This command will close `newfd` if it was a valid descriptor and makes `newfd1` an exact copy of `oldfd`. Two file descriptors will share the same offset.

Note that `dup2(x, 0)` will change `x`'s file descriptor to `stdin` and `dup2(x, 1)` will change `x`'s file descriptor to `stdout`.

### `int fcntl (int fd, F_SETFD, int val)`

This will set the `close on exec` if `val = 1` and clears if `val = 0`. The file descriptor will be made non-inheritable by the new program.

### `int pipe (int fds[2])`

This will return two file descriptors in `fds[0]` and `fds[1]`. Any writes to `fds[1]` will be read on `fds[0]`, and when the last copy of `fds[1]` is closed, then `fds[0]` will return `EOF`. It will return `0` on success and `-1` on error.

Pipes can read, write, and close just like with files. If `fds[1]` is closed, then `read(fds[0])` will return 0 bytes. When `fds[0]` is closed, then `write(fds[1])` and we kill the process.


## Kernel View of Processes

The OS keeps a data structure for each proc (Process Control Block). It will track the information necessary for each process to run, which includes:
* Process State and Process ID
* Registers and Program Counter
* Address Space
* Open Files

If a process is forked, they still share the same addresses, but they do not share memory.

### Preemption

We can preempt a process when the kernel gets control. If there is an interrupt, then we need to save the state of the thread, which are just the values of the registers. Then, we can use a switch statement to understand the content of the interrupt, of which the appropriate kernel code will be executed.

We could have periodic timer interrupts, device interrupts, 


### Scheduling

* If 0 threads are runnable, then halt CPU
* If 1 thread is runnable, then run the thread
* If 2+ threads are runnable, make a scheduling decision.  We could scan the process table, use FIFO/Round-Robin (This is used in OS161) or use priorities.

To demonstrate FIFO, consider thread $A$, $B$, and $C$ (in this order) and suppose $A$ gets to run until it is finished. Then, $B$ gets to run until it is finished. Lastly, $C$ gets to run until it is finished.

Round-Robin is just FIFO but with preemption introduced. So, $A$ runs for a bit then is kicked out. Then, $A$ is placed at the end of the queue and $B$ runs for a bit. Then, $B$ is kicked out, placed at the end of the queue, and $C$ runs for a bit. Now, when $C$ is kicked off, we will run $A$.

To do:

Tidy up these notes (consider doing a return, description, example model)

Prioritize `fork()`, `waitpid()`, and `execve()`

Remember:

2^10 - kibibytes (we say kilobytes)
2^20 - mebibytes (we say megabytes)
2^30 - gibibytes (we say gigabytes)